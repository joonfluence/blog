---
title: Java를 처음 공부하는 당신에게
date: '2023-07-10'
tags: ['Java', 'Lecture']
draft: false
summary: jdk 8 vs jdk 11 vs jdk 17
images: []
layout: PostLayout
canonicalUrl:
---

# 들어가기에 앞서

먼저, 질문을 먼저 드릴게요. 여러분은 코딩을 잘하고 싶으신가요? 저 역시 정말 코딩을 잘하고 싶은 사람 중 하나인데요, 여러분은 코딩을 하는 이유가 무엇인가요? 저는 코딩을 하는 이유는 `문제해결`이라고 생각해요. 그렇다면 코딩을 잘하기 위해선, 어떻게 해야 할까요? 바로 `사용하는 프로그래밍 언어의 탄생 배경`과 `동작 원리`를 이해해야 한다고 생각해요!

이번 글은 `자바를 새롭게 학습하시는 분들을 위한 글`을 작성해봤어요. 사실 이 글은 자바에 관해 잘 알지 못하는 제 자신을 위한 글이기도 해요! 만약 독자 분들께서 비슷한 생각이 드신다면, 이번 글을 통해서 저와 함께 자바란 프로그래밍 언어에 대한 이해를 높여봐요!

# Java의 탄생 배경

먼저, 결론부터 이야기할게요. Java는 1991년 썬 마이크로시스템즈(이하 썬)의 제임스 고슬링과 아서 밴 호프를 주축으로 한 엔지니어들이 `운영체제로부터 독립적으로 실행 가능하도록 개발한 언어`예요. 이해를 높이기 위해서, 잠시 91년도로 돌아가볼까요? 90년대 초는 C와 C++ 의 사용률이 높았던 시절이예요. 그들은 왜 당시 핫했던 C나 C++를 사용하지 않았을까요? 객체지향 프로그래밍을 하려면 C++로도 가능했지만, C++는 운영체제에 따라 컴파일러에 차이가 있어 `실행파일의 플랫폼 간 호환성이 보장되지 않았어요`. 이는 인터넷의 발전으로 다양한 환경에서 실행될 가능성이 높아진 프로그램들을 플랫폼에 따라, 다르게 컴파일해서 실행해야 하는 불편함이 생겼어요. 그래서 썬의 개발자들은 `JVM(Java Virtual Machine)`을 만들어 운영체제와 상관 없이 동일한 코드(컴파일된 코드)를 실행할 수 있도록 만들었어요.

- **컴파일**이란 사람이 이해할 수 있도록 작성한 프로그래밍 언어를 소스 코드를 컴퓨터가 이해할 수 있도록 이진수 형태인 바이트 코드로 변환하는 것을 말해요. 자바의 경우, 컴바일러가 .java 파일을 바이트 코드 .class로 변환해요.

# JVM 동작원리 및 기본 개념

![JVM-Architecture](/static/images/java/step-0/JVM-Architecture.png)

JVM의 동작 원리는 다음과 같아요. JVM은 컴파일된 바이트 코드(.class)를 `클래스 로더`를 통해 `런타임 데이터 영역`에 전달해요. 그리고 `실행 엔진`을 통해 명령어 단위로 하나씩 실행하는 역할을 수행해요. 그래서 클래스 로더, 런타임 데이터 영역, 실행엔진을 알아야 JVM에 알 수 있어요. 이 모든 요소들을 합쳐서 JVM이라고 부르기 때문이죠.

## **클래스 로더**

![클래스로더](/static/images/java/step-0/class_loader.png)

**클래스 로더**는 클래스 로드, 클래스 링킹 (검증, 준비, 분석), 클래스 초기화 과정을 거쳐, `실행 엔진`에서 실행할 수 있도록 `런타임 데이타 영역`에 클래스 파일을 적재하는 역할을 해요. 이 때, 클래스를 메모리에 한 번에 전부 올리는 것이 아니라 어플리케이션에서 필요한 경우마다 동적으로 로딩합니다.

1. 로딩

컴파일된 파일 안에는 단순히 사용자가 작성한 클래스만 존재하지 않아요. Java 내장 API 및 확장 클래스들이 함께 존재하죠. 클래스 로더는 Bootstrap Class Loader, Extension Class Loader, System Class Loader, User-Defined Class Loader로 나뉘며, 이러한 특성을 `계층 구조`라고 이야기해요.

- **부트스트랩 클래스 로더(Bootstrap Class Loader)** : 모든 클래스들의 상위 클래스인 Object 클래스들 비롯해, 자바 API를 로드해요.
- **익스텐션 클래스 로더(Extension Class Loader)** : 다양한 보안 확장 기능 등 확장 클래스들을 로드해요.
- **시스템 클래스 로더(System Class Loader)** : 앞서, 두 로더가 JVM 자체의 구성요소들을 로드했다면 시스템 클래스 로더는 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드해요.
- **사용자 정의 클래스 로더(User-Defined Class Loader)** : 애플리케이션 사용자가 직접 코드 상에서 생성하여 사용하는 클래스 로더를 말한다.

![class_loader_2](/static/images/java/step-0/class_loader_2.png)

또 클래스 로드를 요청받으면, 이전에 로드된 적 있는지 확인하기 위해 클래스 로더 캐시를 확인하고 없으면 아래에서부터 순서대로 해당 클래스가 있는 위치를 확인해요. 이 때 올라가는 도중에 클래스를 발견하더라도 최상위 클래스 로더까지 확인하여 거기에도 동일한 클래스가 존재하면 상위 클래스를 로드해요. 만약 최상위 클래스 로더에 찾는 클래스가 없으면 로드를 요청 받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾아요. 이러한 특성을 `위임 모델`이라고 하며, 위 그림과 같은 구조를 띄어요.

2. 링킹

로드 과정을 거치면 검증, 준비, 분석 단계를 거쳐요.

- 검증 : Bytecode Verifier를 통해, 읽어들인 바이트 코드들이 바르게 생성되었는지 확인해요. 만약 바르게 생성되지 않았다면 검증에 실패하며 오류를 뱉어요.
- 준비 : 클래스가 필요로 하는 메모리를 할당해요. 필요한 메모리란 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 말해요.
- 분석 : 메모리에 적재되지 않았기 때문에 심볼릭 레퍼런스로 참조되던 요소들을 각 요소의 주소를 직접 참조해요.

3. 초기화

클래스 로딩의 마지막 과정으로, 클래스 변수들을 적절한 값으로 초기화해줘요. 여기서 적절한 값이란 사용자가 정의한 값으로 값이 할당되는 것을 의미해요.

## 런타임 데이터 영역

![Runtime-Data-Area](/static/images/java/step-0/Runtime-Data-Area.png)

다음은 런타임 데이터 영역입니다. 런타임 데이터 영역은 애플리케이션이 동작하기 위해 OS에서 할당 받은 메모리 공간을 의미하는데요. 아래 5가지로 구성됩니다.

- 메서드 영역(Method Area)

메서드 영역은 모든 쓰레드가 공유하는 영역으로 JVM이 시작될 때 생성되는 메모리 영역이예요. 이 곳에는 **런타임 상수 풀 (Runtime Constant Pool)**이 있는데, 이 런타임 상수 풀은 각 클래스와 인터페이스의 상수, 메서드와 필드에 대한 레퍼런스 정보를 보관하는 테이블로 JVM 동작의 가장 핵심적인 역할을 수행하는 정보를 보관합니다. 또 GC(Garbage Collector)가 관리하는 메모리 영역 중 하나입니다.

- 힙 영역(Heap Area)

모든 Object와 Instacne를 저장하는 공간으로, 프로그래머가 직접적으로 성능에 영향을 줄 수 있는 메모리 영역 중 하나예요. 생성 후 더 이상 사용되지 않는 클래스는 자동으로 GC(Garbage Collector)가 정리하지만, memory leak 현상이 발생하지 않도록 메모리 관리에 유의해야 해요.

- 스택 영역(Stack Area)

**각 쓰레드를 위해 분리된 런타임 환경**으로, 변수나 임시 데이터, 쓰레드 또는 메서드 정보들을 저장해요. 그리고 스레드 역할이 종료되면 바로 소멸돼요. printStackTrace()를 통해 확인할 수 있는데, 각 라인 하나가 스택 프레임을 표현해요. 또 하나의 스택 프레임에는 LTA(Local Variable Array), OS(Operand Stack), Reference to Constant Pool이 존재해요.

- PC 레지스터(PC Register)

현재 수행 중인 명령의 주소 정보를 보관해요. 스레드가 시작될 때 생성되며, 어떤 명령을 실행해야 할지에 관해 기록해요.

- 네이티브 메서드 스택 (Native Method Stack)

바이트 코드가 아닌 기계어로 작성된 프로그램을 실행하는 영역으로, Java가 아닌 다른 언어로 작성된 코드를 위한 영역이예요. JNI(Java Native Interface)를 통해 바이트 코드로 전환하여 저장할 수 있어요.

## 실행 엔진

![execution_engine](/static/images/java/step-0/execution_engine.png)

이제 런타임 데이터 영역에 바이트 코드가 불러와졌으니, 실행만 남았어요. 실행은 실행 엔진을 통해 이뤄지는데요, **실행 엔진**은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 실행하는 역할을 해요. 실행엔진은 2가지 방식을 이용해 동작하는데요. 하나씩 읽고 해석하고 실행하는 `자바 인터프리터 방식`과 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 바이너리 코드를 직접 실행하는 `JIT 컴파일러 방식`이 있어요.

- Interpreter

바이트 코드를 해석하고 실행하는 역할을 수행해요. 다만 같은 메서드가 여러 번 호출될 때 매번 새로 수행해야 하는 문제가 존재해, 반복되는 코드를 발견하면 JIT 컴파일러를 사용해요.

- JIT Complier

JIT Complier는 Interpreter의 문제를 개선하기 위해 등장했는데요, 반복되는 코드를 발견하여 전체 바이트 코드를 컴파일하고 그것을 Native Code(Java의 부모 격인 C, C++, 어셈블리어 등)로 변경하여 사용합니다. 바이트 코드 전체를 실행하기 때문에 실행 속도가 인터프리터 방식보다 빨라요.

- Garbage Collector

더 이상 참조되지 않는 메모리 객체(Garbage)들을 모아 정해진 시간마다 제거하는 역할을 수행해요. 또 GC가 작동하는 동안, GC 관련 Thread를 제외한 모든 Thread가 멈추게 돼요.

# 정리하며

![JVM-Architecture](/static/images/java/step-0/JVM-Architecture.png)

앞서 나왔던 그림을 보며 다시 정리해보면, 자바 프로그램의 실행 과정은 다음과 같아요.

1. 자바 컴파일러는 자바 소스코드를 읽어, 바이트 코드로 변환해요.
2. 컴파일된 코드는 클래스 로더에 전달되요.
3. 클래스 로더는 동적로딩을 통해 그 때 그 때 필요한 클래스들을 로딩 -> 링킹 -> 초기화 과정을 거쳐 JVM의 Runtime Data Area에 적재해요.
4. 로딩된 바이트 코드는 실행 엔진(Execution Engine)을 통해 실행되요.

이상으로 JVM의 동작 원리에 관하여 알아보았어요. 처음 공부하는 입장에서 어려울 수 있는 내용이지만, 코딩할 때도 알아두면 도움이 되니 반복적으로 읽어보실 것을 권해드려요. 읽어주셔서 감사합니다!

# 참고한 글

[https://d2.naver.com/helloworld/1230](https://d2.naver.com/helloworld/1230) <br />
[https://dzone.com/articles/jvm-architecture-explained](https://dzone.com/articles/jvm-architecture-explained)
